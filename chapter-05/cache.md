# Redis 캐시로 사용 시 주의점
## 1. 캐시 일관성 문제
### 원인
- 캐시와 DB 간의 데이터 불일치가 발생하는 상황
- 쓰기 지연: DB 업데이트 후 캐시가 바로 갱신되지 않음
- 캐시 무효화 시점 불명확: TTL 또는 수동 DEL 시점이 DB 변경과 어긋남
- 복제 지연(replica lag): Redis Cluster 또는 DB replica 사용 시 최신 데이터 반영이 늦어짐
- 네트워크 지연, 장애, 재시도 로직이 꼬이면 일관성 유지가 더 어려워짐


### 대표적인 캐시 갱신 패턴
1. Cache-aside (Lazy loading)
    - 읽기 시 캐시 미스 → DB 조회 → 캐시에 적재
    - 장점: 불필요한 캐시 저장 최소화
    - 단점: 쓰기 시점에 캐시 불일치 발생 가능


2. Write-through
    - DB 업데이트 시 캐시도 동시에 갱신
    - 장점: 일관성 상승
    - 단점: 쓰기 성능 부하 높아짐


3. Write-behind
    - 캐시에 먼저 쓰고, 비동기로 DB 반영
    - 장점: 쓰기 성능 높음
    - 단점: DB 반영 전 장애 시 데이터 유실 위험


### 일관성 맞추는 여러 가지 방법
- TTL + 주기적 리프레시: 오래된 데이터 자동 제거
- 변경 이벤트 기반 캐시 무효화(DB binlog, CDC)
- 버전 키(versioned key): 변경 시 새로운 키 생성하여 캐시 갱신 or 무효화
- 강한 일관성 필요한 경우에는 캐시보다 DB 우선 조회하기 or 캐시 무효화 강제


---
## 2. 캐시 스탬피드 문제
### 정의
캐시 만료 or 미스 시 동일 키에 대한 여러 요청이 동시에 DB 조회로 들어와서 DB 부하가 폭증하는 현상

단일 키뿐만 아니라 여러 키가 동시에 만료되는 경우 **캐시 애벌랜치(avalanche)** 문제로 확장된다.


### 현상이 발생하는 다양한 원인
- TTL이 동일하게 설정되어 있어 동시 만료 발생
- 캐시 조회 로직 때, 같은 요청 병합 없이 모든 요청을 DB로 보내는 경우
- 인기 키(핫키)에 트래픽 집중되는 경우
- Redis Cluster에서 특정 슬롯/노드 핫스팟 문제 생긴 경우


### 영향
- 순간적인 DB QPS 급등 → 응답 지연·타임아웃·서비스 장애
- DB 커넥션 풀 고갈, 스레드풀 대기, 재시도 폭증 등 2차 장애 유발


### 현상 완화 방법
1. TTL Jitter(랜덤화)
    - 동시에 만료되는 TTL 패턴이 많은 경우
    - TTL에 ±10~30% 랜덤값 추가 → 동시 만료 분산
    - [토스 테크에서 설명하는 기본적인, 이론적인 완화 방법](https://toss.tech/article/cache-traffic-tip)


2. Request Coalescing (Single-flight)
    - 동일 키에 대한 동시 캐시 미스 → 최초 1개의 요청만 DB 조회
    - 나머지는 대표 요청의 결과를 기다림


3. Write-through
    - 변경 시 즉시 캐시에 반영 → TTL 만료로 인한 미스 자체를 줄임
    - 일관성이 강하게 필요한 경우, 쓰기 성능을 감수하더라도 도입


4. Two-Level 캐시 구조
    - 만약, 캐싱할 대상이 Universal한 데이터라면 서버 별 로컬 캐시에 미리 캐싱
    - 캐시 갱신됐을 때 pub/sub 등으로 비동기 키 삭제
    - 로컬 캐시 비어있으면 글로벌 캐시 계층에서 읽어오도록 함 (DB에 아예 부하를 보내지 않음)
    - 이 때, 글로벌 Redis만 잘 갱신되어있으면 문제 없음

---
## Refs.
- [캐시 전략 최적화, 구조 리팩토링](https://github.com/Pearl-K/FoodOn)