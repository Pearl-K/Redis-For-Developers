# Redis 이벤트 루프 기반 동작과 클라이언트 비동기 처리 방식


Redis가 어떻게 이벤트 루프 기반 싱글 스레드 구조로 수천 ~ 수만 개의 클라이언트 요청을 처리할 수 있는지에 대해 설명한다.


또한, `BLPOP`과 같은 블로킹 명령어에서 클라이언트가 어떻게 대기 상태에 놓이고, 그럼에도 불구하고 Redis는 어떻게 서버 전체 응답성을 유지하는지도 설명한다.


---
## 1. 이벤트 루프 기반 싱글 스레드란?

Redis는 단일 스레드로 모든 명령을 처리한다. 그러나 이는 **하나의 작업만 처리 가능하다**는 의미가 아니다.


Redis는 OS의 비동기 I/O API (epoll, kqueue, select)를 활용한 이벤트 루프(event loop) 구조를 갖고 있어, 클라이언트 요청을 감지하고 순차적으로 처리한다.


### 핵심 구조

```c
while (server is running) {
    1. 클라이언트 I/O 이벤트 감지 (epoll_wait)
    2. 들어온 명령 파싱
    3. 명령 실행
    4. 응답 전송
    5. 주기 작업 (만료 키 정리 등)
}
````

이 구조는 **Node.js, Nginx, Netty, Kafka** 등 고성능 서버들이 공유하는 패턴이다.


---
## 2. OS 비동기 I/O API는 무엇인가?

### epoll (Linux), kqueue (BSD), select 등

이들은 OS 커널에서 제공하는 시스템 호출로, 수천 개의 소켓을 등록해놓고 "어디에서 데이터가 왔는지만 감지"할 수 있다.

```c
epoll_wait(epfd, events, MAX_EVENTS, timeout);
```

* 성능: O(1) 감지
* Redis는 여기에 클라이언트 소켓들을 등록해두고, **데이터가 들어온 소켓만 처리한다.**


이 덕분에 Redis는 10,000개의 클라이언트를 연결하더라도
→ 실제 데이터가 들어오는 클라이언트 명령만 처리하면 되므로 부하가 낮다.


---
## 3. 클라이언트 요청은 어떻게 처리되나?

1. epoll을 통해 이벤트 감지
2. 해당 소켓에서 데이터 읽기
3. 명령 파싱 및 처리
4. 결과 응답 작성 및 전송

이 루프는 단일 스레드에서 순차적, atomic하게 수행되므로
→ 동시에 같은 키를 수정할 일이 없다 (race condition X)


---
## 4. 클라이언트 대기 상태 만들기

### `BLPOP`

BLPOP은 클라이언트를 대기 상태로 만들지, 레디스 서버가 블로킹 되는 연산이 아니다. 정확히 아래와 같은 순서로 동작한다.


```redis
BLPOP myqueue 0
```

* 해당 리스트에 데이터가 없으면, Redis는 응답을 주지 않고 클라이언트를 **"BLOCKED" 상태로 등록**한다.
* 이 클라이언트는 **server.blocked\_clients** 리스트에 들어가며,
* 해당 키 `myqueue` 를 기다리는 중이라는 정보가 `client->bpop.key`에 저장된다.

이때 Redis는 메인 루프에서 이 클라이언트를 건너뛰고,
다른 클라이언트 요청을 계속 정상 처리한다.


### 트리거 방식 처리

* 나중에 누군가가 `RPUSH myqueue "data"` 하면,
* Redis는 `blocked_clients`에서 `"myqueue"`를 기다리는 클라이언트를 찾아 즉시 응답을 보내고 BLOCK을 해제한다.


---
## 5. 그럼 대기 클라이언트가 많아지면 병목일까?

### 대기 클라이언트 탐색은 기본적으로 O(N)

* Redis는 `blocked_clients` 리스트를 순회하며 기다리는 클라이언트를 찾는다.
* 그러나 실무에서는 대기 클라이언트가 그렇게 많지 않고,
* **bucketized 구조나 key-indexed dict** 구조로 최적화돼 있어 실제 성능 저하가 크지 않다.

→ 만약, 수천 개의 `BLPOP`이 동시에 존재하는 구조라면 Redis보다 **Kafka / Redis Streams**가 적합한 구조이다.

---

## 6. Redis가 빠른 이유는 구조적 근거 때문

| 요소          | 설명                                      |
| ----------- | --------------------------------------- |
| OS I/O 비동기화 | `epoll`을 통해 데이터 있는 소켓만 감지                 |
| 이벤트 루프      | 순차 처리 + race free 구조                    |
| 명령 처리       | atomic, 단일 스레드                          |
| 대기 클라이언트    | BLOCK 상태로 등록, 트리거 기반 해제                 |
| 별도 스레드 사용   | AOF, RDB, 클라이언트 I/O 등 일부는 백그라운드 스레드로 분리 |

---

## 7. 참고 구조

```c
[Client1] ─┐
[Client2] ─┤   ──> [ epoll ] → 이벤트 루프 진입 (데이터 있는 소켓만)
[Client3] ─┘

    ↓

while (running) {
    read();
    parseCommand();
    execute();
    writeReply();
}
```

---

## Summary

Redis가 싱글 스레드이지만 빠른 이유
- epoll 기반 이벤트 루프
- 트리거 기반 처리
- 대기 상태에 대한 클라이언트 구조체 등록 & 관리
- 경량화된 명령 처리 모델

