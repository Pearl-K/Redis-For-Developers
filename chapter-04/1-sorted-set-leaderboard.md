# Sorted Set LeaderBoard
리더보드에는 크게 두 가지 유형이 있다.
1. 절대적 리더보드: 서비스의 모든 유저를 정렬시켜 상위권 목록만 표시함
2. 상대적 리더보드: 사용자마다 다른 데이터를 보여준다. (ex. 사용자 근처 데이터, 사용자 맞춤 데이터 등)


토이 프로젝트 규모에서 Sorted Set을 사용하여 리더보드를 구현하는 것은 어렵지 않다. 아래와 같은 명령어를 사용하여 구현하며 된다.
- `ZADD`, `ZINCRBY` 등의 연산으로 set과 score 잘 관리하기
- `ZUNIONSTORE` 를 통해 랭킹 합산하기
- `WEIGHTS` 옵션을 통해 가중치 주기


Sorted Set을 잘 활용하려면 유저나 랭킹 데이터가 많은 대규모 시스템에서의 활용 방법을 알아야한다고 생각하여 정리했다.

---
## 대규모 시스템에서의 리더보드 관리 전략

소규모에서는 단일 인스턴스에서 Redis Sorted Set으로 간단하게 사용할 수 있지만, 대규모 환경에서는 **메모리, 확장성, 실시간성**을 고려해야 한다.

---

## 1. 핵심 고려사항
- **데이터 규모**: 수백만~억 단위 유저의 데이터 ranking 관리
- **실시간성 요구 정도**: 순위 갱신이 실시간/근실시간인지
- **조회 패턴**: Top-N, 내 주변 순위, 구간별 페이지네이션 중 어떤 것인지
- **기간 관리**: 주간/월간/이벤트 기간 단위의 구분 (Key 관리에도 중요)
- **샤딩 필요성**: 단일 키에 담기 어려운 데이터 규모일 때 어떻게 처리할건지

---

## 2. 여러 가지 전략 비교

| 전략 | 구조 | 장점 | 단점 | 적용 사례 |
|------|------|------|------|----------|
| **단일 ZSET** | 모든 유저를 한 Sorted Set에 저장 | 구현 단순, 실시간 | 메모리/확장성 한계, 단일 노드 부하 집중 | 소규모, 단일 서버 |
| **샤드별 ZSET + 조회 시 K-way Merge** | 유저를 샤드로 분리, Top-M만 병합 | 확장성, 정확성 유지 | 조회 시 부하 증가 | 글로벌 Top-N, MMR 분산 |
| **샤드별 ZSET + 전역 Top-N 유지(이중 쓰기)** | 샤드별로 점수 기록 + 전역 ZSET 업데이트 | 조회 빠름, 실시간성 유지 | 쓰기 부하 증가, 동기화 로직 필요 | 글로벌 Top-N 실시간 노출 |
| **샤드별 ZSET + 주기적 배치 집계** | 주기적으로 Top-M 집계 후 전역 ZSET 갱신 | 쓰기 부하 적음, 확장성 | 실시간성 낮음 | 주간/월간 이벤트 |
| **조건별/리그별 ZSET** | 리그, 레벨, 지역별로 분리 | 한 키의 크기 감소 | 전역 순위 계산 어려움 | 게임 랭킹, 리그전 |

---

## 3. 전략별 구체적인 아키텍처

### 3.2 샤드별 ZSET + 조회 시 K-way Merge

```text
[Shard1] leaderboard:1
[Shard2] leaderboard:2
...
[ShardK] leaderboard:K
```

* 절차
  1. 각 샤드에서 Top-M 조회
  2. 애플리케이션에서 **우선순위 큐(min-heap)** 로 병합


* 장점: 확장성이 우수하다
* 단점: 샤드가 많을 경우, 일일히 가져오는 조회 비용이 좀 더 소모된다.
* 한계점: 각 샤드에서 Top-M만 뽑아 병합할 때, M이 너무 작으면 전역 Top-N 정보가 틀릴 수 있다. 별도의 정확성 보장 방법이 필요하다.


정확성 보장 방법 중에는, 
- 보수적으로 각 샤드에서 최소 N개를 가져와 병합(But, N이 크다면 네트워크 비용↑)하는 방식
- 또는, 적응형 패치 전략(merge 중 현재 N위 최소 점수보다 높은 후보가 더 있을 때만 각 샤드에서 추가로 가져옴)
- 또는, 샤드별 점수 분포 상한(백분위/임계값)을 운영 지표로 두고 Top-M 산정하는 방식이 있다.


> 모두 별도의 비용이 소모되기 때문에 현재 애플리케이션에서 어떤 전략이 맞을지 trade-off를 따져봐야 한다.


---

### 3.3 샤드별 ZSET + 전역 Top-N ZSET 유지

```text
[Shard1] leaderboard:1
[Shard2] leaderboard:2
...
[Global] leaderboard:globalTop
```

* 쓰기 발생할 때

  1. 해당 샤드 업데이트
  2. 전역 Top-N 후보인지 체크 후 업데이트

* 구현 방식: Lua 스크립트로 원자적 처리

---

### 3.4 샤드별 ZSET + 주기적 배치 집계(Application)

```text
[Shard1..K] → (Batch Job) → [Global] leaderboard:globalTop
```

* 주기적으로 애플리케이션 계층에서 병합 실행 (ex. 매 5분, 1시간)
* 실시간성보다 전체 규모, 안정성을 우선으로 한다. 


---

## 4. 설계 팁

### 4.1 메모리 최적화

* 담을 멤버 정보를 최소화하여 숫자 ID로만 저장한다. (닉네임, 아바타 등은 해시/HGET으로 별도 조회)
* 특정 기간을 기준으로 두고, 기간별로 키 분리 (`leaderboard:{yyyyMM}`)


### 4.2 조회 최적화

* 내 주변 순위:

  ```bash
  rank = ZREVRANK leaderboard:global user123
  ZREVRANGE leaderboard:global (rank-10) (rank+10) WITHSCORES
  ```
* Top-N: `ZREVRANGE ... 0 N-1 WITHSCORES`


### 4.3 샤딩 기준

* User ID 해싱을 통해 샤딩할 수 있다. (기본적으로 User에 대한 랭킹 정보를 주는 경우가 많으므로)
* 모드/리그/지역 기반 서비스가 필요하다면 해당 기준으로 분리한다.
* 단, 랭킹 합산을 할 때 주의해야한다. 같은 샤드에서만 `ZUNIONSTORE` 사용이 가능하기 때문에, 샤딩 환경이라면 Sorted Set을 어떻게 활용할지 명확히 설계해야 한다.

---

## 5. 상황에 따른 권장 전략 패턴

| 조건                   | 추천 전략                  |
| -------------------- | ---------------------- |
| 유저 수 적음, 단일 노드 가능  | 단일 ZSET                |
| 글로벌 Top-N 정확성 + 확장성  | 샤드별 ZSET + K-way Merge |
| 글로벌 Top-N 실시간성 최우선  | 샤드별 ZSET + 전역 Top-N 유지 |
| 실시간성 낮고 규모 크다       | 샤드별 ZSET + 주기적 배치 집계   |
| 조건별 소규모 랭킹           | 조건별/리그별 ZSET           |


